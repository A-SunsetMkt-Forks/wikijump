ignoreCase: true

# templates:
  # (@1): name
  # (@2): symbol/mark
  # formatting_pair:
  #   - type: (@1)Open
  #     match: (@2)
  #     closedBy: (@1)Close
  #     tag: processingInstruction
  #   - type: (@1)Close
  #     match: (@2)
  #     openedBy: (@1)Open
  #     tag: processingInstruction
  #   - type: (@1)
  #     begin: (@1)Open
  #     end: (@1)Close
  #     inside: inherit

repository:
  # basic variables (used in regex)
  ws: /[^\S\r\n]/
  esc: /@ws(?:_|\\)$/
  sws: /^(?!@esc)@ws*/
  enl: /^@ws*$/
  control: /[\s!"#$%&'()*+,\-./:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/
  nocontrol: /[^\s!"#$%&'()*+,\-./:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/
  escapes: /\\@control/

  # basic node types

  QuoteMark:
    tag: punctuation
    closedBy: QuoteMark
    openedBy: QuoteMark

  String:
    tag: string

  CSSAttributes:
    nest: css-attribute

  # global

  EscapedNewLine:
    match: /@esc/
    tag: escape

  EscapedCharacter:
    match: /@escapes/
    tag: escape

  BlockComment:
    match: /(\[!--)([^]+?)(--\])/
    tag: (...) blockComment
    captures:
      0: { open: BlockComment }
      2: { close: BlockComment }
    fold: offset(3, -3)

  NonControl:
    match: /@nocontrol+/
    emit: false

  # formatting

  # formatting open/close lookahead
  fmtola: /(?=\S)/
  fmtcla: /(?![^\W\d_])/

  Strong:
    tag: (...) strong
    inside: loose
    begin:
      open: Strong
      lookbehind: '!/\\|\w/'
      match: /\*\*@fmtola/
      tag: processingInstruction
    end:
      close: Strong
      lookbehind: /\S/
      match: /\*\*@fmtcla/
      tag: processingInstruction

  Emphasis:
    tag: (...) emphasis
    inside: loose
    begin:
      open: Emphasis
      lookbehind: '!/\\|\w/'
      match: /\/\/@fmtola/
      tag: processingInstruction
    end:
      close: Emphasis
      lookbehind: /\S/
      match: /\/\/@fmtcla/
      tag: processingInstruction

  Underline:
    tag: (...) special(emphasis)
    inside: loose
    begin:
      open: Underline
      lookbehind: '!/\\|\w/'
      match: /__@fmtola/
      tag: processingInstruction
    end:
      close: Underline
      lookbehind: /\S/
      match: /__@fmtcla/
      tag: processingInstruction

  Strikethrough:
    tag: (...) special(deleted)
    inside: loose
    begin:
      open: Strikethrough
      lookbehind: '!/\\|\w/'
      match: /--@fmtola/
      tag: processingInstruction
    end:
      close: Strikethrough
      lookbehind: /\S/
      match: /--@fmtcla/
      tag: processingInstruction

  Subscript:
    tag: (...) character
    inside: loose
    begin:
      open: Subscript
      lookbehind: '!/\\|\w/'
      match: /,,@fmtola/
      tag: processingInstruction
    end:
      close: Subscript
      lookbehind: /\S/
      match: /,,@fmtcla/
      tag: processingInstruction

  Superscript:
    tag: (...) character
    inside: loose
    begin:
      open: Superscript
      lookbehind: '!/\\|\w/'
      match: /\^\^@fmtola/
      tag: processingInstruction
    end:
      close: Superscript
      lookbehind: /\S/
      match: /\^\^@fmtcla/
      tag: processingInstruction

  Monospace:
    tag: (...) monospace
    inside: loose
    begin:
      open: Monospace
      lookbehind: '!/\\|\w/'
      match: /\{\{@fmtola/
      tag: processingInstruction
    end:
      close: Monospace
      lookbehind: /\S/
      match: /\}\}@fmtcla/
      tag: processingInstruction

  # special

  LinkInline:
    match: /(\*?)((?:\w+://)?(?:[-\w@:%.+~#=]{2,256}\.(?!\.{2,3}))+?[a-z]{2,6}\b(?:[-\w@:%+.~#?&/=]*))/
    captures:
      0: { type: LinkModifier, tag: keyword }
      1: { type: LinkURL, tag: url }

  IncludeVariable:
    match: /(\{\$)(.*?)(\})/
    captures:
      0: { open: IncludeVariable, tag: bracket }
      1: { type: IncludeVariableName, tag: variableName }
      2: { close: IncludeVariable, tag: bracket }

  PageVariable:
    match: /(%%)(.*?)(\{.*?\})?(%%)/
    captures:
      0: { open: PageVariable, tag: bracket }
      1: { type: PageVariableName, tag: variableName }
      2: { type: PageVariableAccessor, tag: string }
      3: { close: PageVariable, tag: bracket }

  # markup

  RawEscapeBlock:
    begin: { match: '@<', open: RawEscapeBlock, tag: processingInstruction }
    end: { match: '>@', close: RawEscapeBlock, tag: processingInstruction }
    tag: escape
    inside:
      - { type: EntityReference, match: '/&[\w#]+;/', tag: character }
    fold: offset(2, -2)

  # @@ escape formatting (AKA the worst thing ever)
  Escaped:
    match: [/(@@)(@@)(@@)/, /(@@)(@)(@@)/, /(@@)()(@@(?!@))/, /(@@)(.*)(@@)/]
    tag: escape
    captures:
      0: { open: Escaped, tag: processingInstruction }
      2: { close: Escaped, tag: processingInstruction }

  ColoredText:
    begin:
      match: /(##)(#?[^\n\|]+)(\|)/
      captures:
        0: { open: ColoredText, tag: processingInstruction }
        1: { type: ColoredTextColor, tag: color }
        2: { type: ColoredTextSeparator, tag: separator }
    end:
      close: ColoredText
      match: "##"
      tag: processingInstruction

  Typography:
    tag: processingInstruction
    match:
      # ``quotation''
      - /``(?=(?!``).+?'')/
      - /(?<=``(?!'').+?)''/
      # `quotation'
      - /`(?=(?!`).+?')/
      - /(?<=`(?!').+?)'/
      # ,,quotation'' (this one is so damn stupid)
      - /,,(?=(?!,,).+?'')/
      - /(?<=,,(?!,,).+?)''/
      # <<, >>
      - /<<|>>/
      # ...
      - /\.{3}/
      # --
      - /(?<=\s)--(?=\s)/

  # block markup

  # symbols that interrupt a paragraph on line start
  interrupt: /(?:\++\*?@ws)|(?:[\[\]])|(?:[*#]@ws)|(?:[-=]{4,})|(?::)|(?:>+@ws)|(?:>$)|(?:\|{2})/

  hr: /(?:-{3,}|={3,})@ws*$/
  heading: /(?:\++\*?)@ws+(?!$)/
  cs: /@sws(?:(?:>+@ws|>|[*#]@ws)@ws*)+/

  HorizontalRule:
    match: /@sws@hr/
    tag: contentSeparator

  Heading:
    begin: { type: HeadingMark, match: /@sws@heading/, tag: heading }
    end: { match: /$/ }
    inside:
      - include: inline

  Center:
    begin: { type: CenterMark, match: /@sws=@ws+/, tag: heading }
    end: { match: /$/ }
    inside:
      - include: inline

  Table:
    begin:
      match: /@sws\|{2}/
      rematch: true
    end:
      lookbehind: '!/@esc\s*/'
      match: /@enl|^(?:(?!\|{2}).)+$/
      rematch: true
    inside:
      - type: TableMark
        match: /(\|{2,})([~=]?)/
        captures:
          0: { type: TableMarkSeparator, tag: separator }
          1: { type: TableMarkModifier, tag: operator }
      - include: inline
    fold: past_first_line

  ContainerMark:
    match: /@sws>+|[*#]/
    tag: keyword

  Container:
    begin:
      match: /@cs/
      rematch: true
    end:
      lookbehind: '!/@esc\s*/'
      match: /@enl|(?!@cs)@sws/
      rematch: true
    inside:
      # TODO: heading/center in containers
      - ContainerMark
      - include: inline
    fold: past_first_line

  Paragraph:
    begin: { match: /@sws(?!@interrupt)\S/, rematch: true }
    end: { match: /@sws(?:@interrupt)|@enl/, rematch: true }
    inside:
      - include: inline
    fold: past_first_line

  # blocks (basics)

  BlockStart:
    match: /\[{2}(?![\[/])\s*/
    tag: squareBracket
    closedBy: BlockEnd

  BlockClosingStart:
    match: /\[{2}/\s*/
    tag: squareBracket
    closedBy: BlockEnd

  BlockEnd:
    match: /\s*(?!\]{3})\]{2}/
    tag: squareBracket
    openedBy: [BlockStart, BlockClosingStart]

  BlockName:
    match: /(?:[*=><](?![*=><])|f>|f<)?([^\\#*\s\]]+?)(_?(?=@ws|@BlockEnd|$))/
    emit: false
    captures:
      0: { type: BlockNamePrefix, tag: keyword }
      1: { type: BlockNameActual, tag: tagName, emit: BlockName }
      2: { type: BlockNameSuffix, tag: modifier }

  BlockLabel:
    match: /(\S+?)(?=$|\s|@BlockEnd)/
    tag: invalid

  # blocks (map)

  # BlockNodeMap:
  #   emit: BlockNode
  #   chain:
  #     - BlockStart
  #     - BlockName
  #     - ws*
  #     - BlockNodeArgument* | BlockLabel*
  #     - BlockEnd

  # BlockEndNode:
  #   emit: BlockNode
  #   chain:
  #     - BlockStartClosing
  #     - BlockName
  #     - BlockEnd

  BlockNodeArgument:
    match: /(\S+?)(\s*=\s*)(")((?:[^"]|\\")*)(")/
    context: { if: $0, matches: type, set: code-lang, to: $3 }
    captures:
      0: { type: BlockNodeArgumentName, tag: special(propertyName) }
      1: { type: BlockNodeArgumentOperator, tag: definitionOperator }
      2: { is: QuoteMark }
      3: { if: $0, matches: style, then: { is: CSSAttributes }, else: { is: String }}
      4: { is: QuoteMark }

  BlockContainerMap:
    emit: BlockContainer
    begin: BlockStart
    end: BlockEnd
    inside: inherit

includes:
  special:
    - LinkInline
    - IncludeVariable
    - PageVariable

  markup:
    - Typography
    - RawEscapeBlock
    - Escaped
    - ColoredText

  formatting:
    - Strong
    - Emphasis
    - Underline
    - Strikethrough
    - Subscript
    - Superscript
    - Monospace

  block:
    - HorizontalRule
    - Heading
    - Center
    - Table
    - Container
    - Paragraph

  inline:
    - Typography
    - LinkInline
    - IncludeVariable
    - PageVariable
    - RawEscapeBlock
    - Escaped
    - ColoredText
    - Strong
    - Emphasis
    - Underline
    - Strikethrough
    - Subscript
    - Superscript
    - Monospace

  blocks:
    - BlockContainerMap

global:
  - EscapedNewLine
  - EscapedCharacter
  - BlockComment
  - NonControl

root:
  - include: block
  - include: inline
