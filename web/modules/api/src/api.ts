import { readable, Subscriber } from "svelte/store"
import { Api, RequestParams } from "../vendor/api"

const API_PATH = "/api--v0"

class WikijumpAPIInstance extends Api<void> {
  // private properties have _ as a prefix to prevent conflicting with any
  // autogenerated API methods

  /** Current CSRF token. */
  private declare _CSRF: string

  /** @param headers - Extra headers to send with every request. */
  constructor(headers: Record<string, string> = {}) {
    super({
      baseUrl: API_PATH,
      baseApiParams: {
        headers: {
          "Accept": "application/json",
          "Content-Type": "application/json",
          ...headers
        },
        secure: true,
        format: "json"
      },
      securityWorker: (): RequestParams => {
        const csrf = this._CSRF
        const xsrf = getCSRFCookie()
        if (xsrf) return { headers: { "X-CSRF-TOKEN": csrf, "X-XSRF-TOKEN": xsrf } }
        else return { headers: { "X-CSRF-TOKEN": csrf } }
      }
    })

    this._CSRF = getCSRFMeta()
    this._hijackAuthMethods()

    // update authentication status, as we may already be logged in
    this.authCheck().catch()
  }

  private _hijackAuthMethods() {
    // authLogin and authRefresh are special in that they regenerate your session.
    // this invalidates your old CSRF token, so we need to update it,
    // which means overriding the old methods with new ones.

    // additionally, we want to update the authed store to whatever
    // our authentication status is.
    // so, we need to hijack all the auth methods

    // unfortunately we can't use super.function because
    // the auto-generated "method" is actually a value and not a method.

    const login = this.authLogin.bind(this)
    const logout = this.authLogout.bind(this)
    const refresh = this.authRefresh.bind(this)
    const check = this.authCheck.bind(this)

    this.authLogin = async (data, requestParams) => {
      const res = await login(data, requestParams)
      this._CSRF = res.csrf
      authSet(true)
      return res
    }

    this.authLogout = async requestParams => {
      await logout(requestParams)
      authSet(false)
    }

    this.authRefresh = async requestParams => {
      const res = await refresh(requestParams)
      this._CSRF = res.csrf
      return res
    }

    this.authCheck = async requestParams => {
      const res = await check(requestParams)
      authSet(res.authed)
      return res
    }
  }
}

let authSet: Subscriber<boolean>

/** Readable store holding the current authentication state. */
export const authed = readable(false, set => void (authSet = set))

let isAuthedBinding = false
authed.subscribe(state => void (isAuthedBinding = state))

/** Returns the current authentication state. */
export function isAuthenticated() {
  return isAuthedBinding
}

/** Wikijump API. */
export const WikijumpAPI = new WikijumpAPIInstance()

/**
 * Retrieves the CSRF token from the `<meta name="csrf-token" ...>` tag in
 * the `<head>`. This should always be present, so this function throws if
 * that element can't be found.
 */
function getCSRFMeta() {
  const meta = document.head.querySelector("meta[name=csrf-token]")
  if (!meta) throw new Error("No CSRF meta tag found")
  return meta.getAttribute("content")!
}

/** Retrieves the CSRF token from the `XSRF-TOKEN` cookie, if it exists. */
function getCSRFCookie() {
  const value = document.cookie
    .split(/;\s*/)
    .find(c => c.startsWith("XSRF-TOKEN="))
    ?.split("=")[1]
  return value
}
